Moore's Voting Algo:
Approach:
* Initialize 2 variables: countfor tracking the count of elements and element for keeping a track of the element we are counting.
* Traverse through the given array. If count is 0 then store the current value of the array as element .
* If the current array value andelement are the same increase the count by 1. If they are different decrease the count by 1. The integer present in element should be the result expected.

1. Majority Element(Optimal Approach using Moore's Voting Algo)

class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int majEle = -1;
        int cnt = 0;
        for(int i=0; i<nums.size(); i++)
        {
            if(cnt == 0)
            {
                majEle = nums[i];
                cnt++;
            }
            else if(majEle == nums[i])
            {
                cnt++;
            }
            else{
                cnt--;
            }
        }
        int cnt1 = 0;
        for(int i=0; i<nums.size();i++)
        {
            if(majEle == nums[i])
            {
                cnt1++;
            }
        }
        if(cnt1 > (int) (nums.size()/2))
            return majEle;
        
        return -1;

        
    }
};

2. Leaders in an Array(Optimal)

#include<algorithm>
class Solution {
public:
    vector<int> leaders(vector<int>& nums) {
        int maxi = INT_MIN;
        vector<int> ans;
        maxi = max(maxi, nums[nums.size()-1]);
        ans.push_back(maxi);
        for(int i=nums.size()-2; i>=0; i--)
        {
            if(nums[i] > maxi)
            {
                maxi = nums[i];
                ans.push_back(maxi);
            }
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};

3. Spiral Matrix(Checks implementation and ability to code clean)

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        vector<int> ans;

        int top = 0, bottom = n-1, left = 0, right = m-1;

        while(top <= bottom && left <= right)
        {
            for(int i = left; i<= right; i++)
            {
                ans.push_back(matrix[top][i]);
            }      
            top++;
            for(int i = top; i<= bottom; i++)
            {
                ans.push_back(matrix[i][right]);
            }
            right--;
            if(top <= bottom)
            {
                for(int i = right; i>= left; i--)
                {
                    ans.push_back(matrix[bottom][i]);
                }
                bottom--;
            }
            if(left <= right)
            {
                for(int i = bottom; i>= top; i--)
                {
                    ans.push_back(matrix[i][left]);
                }
                left++;
            }
        }
        return ans;
    }
};
